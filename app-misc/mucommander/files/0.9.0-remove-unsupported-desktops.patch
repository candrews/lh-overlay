diff --git a/main/com/mucommander/commons/file/impl/local/LocalFile.java b/main/com/mucommander/commons/file/impl/local/LocalFile.java
index 49f3266..e0bf995 100644
--- a/main/com/mucommander/commons/file/impl/local/LocalFile.java
+++ b/main/com/mucommander/commons/file/impl/local/LocalFile.java
@@ -52,8 +52,8 @@ import com.mucommander.commons.file.ProtocolFile;
 import com.mucommander.commons.file.UnsupportedFileOperation;
 import com.mucommander.commons.file.UnsupportedFileOperationException;
 import com.mucommander.commons.file.filter.FilenameFilter;
-import com.mucommander.commons.file.util.Kernel32;
-import com.mucommander.commons.file.util.Kernel32API;
+//import com.mucommander.commons.file.util.Kernel32;
+//import com.mucommander.commons.file.util.Kernel32API;
 import com.mucommander.commons.file.util.PathUtils;
 import com.mucommander.commons.io.BufferPool;
 import com.mucommander.commons.io.FilteredOutputStream;
@@ -149,15 +149,15 @@ public class LocalFile extends ProtocolFile {
                                                    "iso9660", "jfs", "minix", "msdos", "ncpfs", "nfs", "nfs4", "ntfs",
                                                    "qnx4", "reiserfs", "smbfs", "udf", "ufs", "usbfs", "vfat", "xfs" };
 
-    static {
-        // Prevents Windows from poping up a message box when it cannot find a file. Those message box are triggered by
-        // java.io.File methods when operating on removable drives such as floppy or CD-ROM drives which have no disk
-        // inserted.
-        // This has been fixed in Java 1.6 b55 but this fixes previous versions of Java.
-        // See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4089199
-        if(IS_WINDOWS && Kernel32.isAvailable())
-            Kernel32.getInstance().SetErrorMode(Kernel32API.SEM_NOOPENFILEERRORBOX|Kernel32API.SEM_FAILCRITICALERRORS);
-    }
+//    static {
+//        // Prevents Windows from poping up a message box when it cannot find a file. Those message box are triggered by
+//        // java.io.File methods when operating on removable drives such as floppy or CD-ROM drives which have no disk
+//        // inserted.
+//        // This has been fixed in Java 1.6 b55 but this fixes previous versions of Java.
+//        // See http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4089199
+//        if(IS_WINDOWS && Kernel32.isAvailable())
+//            Kernel32.getInstance().SetErrorMode(Kernel32API.SEM_NOOPENFILEERRORBOX|Kernel32API.SEM_FAILCRITICALERRORS);
+//    }
 
     /**
      * Creates a new instance of LocalFile and a corresponding {@link File} instance.
@@ -260,68 +260,69 @@ public class LocalFile extends ProtocolFile {
 
         try {
             // OS is Windows
-            if(IS_WINDOWS) {
-                // Use the Kernel32 DLL if it is available
-                if(Kernel32.isAvailable()) {
-                    // Retrieves the total and free space information using the GetDiskFreeSpaceEx function of the
-                    // Kernel32 API.
-                    LongByReference totalSpaceLBR = new LongByReference();
-                    LongByReference freeSpaceLBR = new LongByReference();
-
-                    if(Kernel32.getInstance().GetDiskFreeSpaceEx(absPath, null, totalSpaceLBR, freeSpaceLBR)) {
-                        dfInfo[0] = totalSpaceLBR.getValue();
-                        dfInfo[1] = freeSpaceLBR.getValue();
-                    }
-                    else {
-                        LOGGER.warn("Call to GetDiskFreeSpaceEx failed, absPath={}", absPath);
-                    }
-                }
-                // Otherwise, parse the output of 'dir "filePath"' command to retrieve free space information, if
-                // running Window NT or higher.
-                // Note: no command invocation under Windows 95/98/Me, because it causes a shell window to
-                // appear briefly every time this method is called (See ticket #63).
-                else if(OsVersion.WINDOWS_NT.isCurrentOrHigher()) {
-                    // 'dir' command returns free space on the last line
-                    Process process = Runtime.getRuntime().exec(
-                            (OsVersion.getCurrent().compareTo(OsVersion.WINDOWS_NT)>=0 ? "cmd /c" : "command.com /c")
-                            + " dir \""+absPath+"\"");
-
-                    // Check that the process was correctly started
-                    if(process!=null) {
-                        br = new BufferedReader(new InputStreamReader(process.getInputStream()));
-                        String line;
-                        String lastLine = null;
-                        // Retrieves last line of dir
-                        while((line=br.readLine())!=null) {
-                            if(!line.trim().equals(""))
-                                lastLine = line;
-                        }
-
-                        // Last dir line may look like something this (might vary depending on system's language, below in French):
-                        // 6 Rep(s)  14 767 521 792 octets libres
-                        if(lastLine!=null) {
-                            StringTokenizer st = new StringTokenizer(lastLine, " \t\n\r\f,.");
-                            // Discard first token
-                            st.nextToken();
-
-                            // Concatenates as many contiguous groups of numbers
-                            String token;
-                            String freeSpace = "";
-                            while(st.hasMoreTokens()) {
-                                token = st.nextToken();
-                                char c = token.charAt(0);
-                                if(c>='0' && c<='9')
-                                    freeSpace += token;
-                                else if(!freeSpace.equals(""))
-                                    break;
-                            }
-
-                            dfInfo[1] = Long.parseLong(freeSpace);
-                        }
-                    }
-                }
-            }
-            else if(OsFamily.getCurrent().isUnixBased()) {
+//            if(IS_WINDOWS) {
+//                // Use the Kernel32 DLL if it is available
+//                if(Kernel32.isAvailable()) {
+//                    // Retrieves the total and free space information using the GetDiskFreeSpaceEx function of the
+//                    // Kernel32 API.
+//                    LongByReference totalSpaceLBR = new LongByReference();
+//                    LongByReference freeSpaceLBR = new LongByReference();
+//
+//                    if(Kernel32.getInstance().GetDiskFreeSpaceEx(absPath, null, totalSpaceLBR, freeSpaceLBR)) {
+//                        dfInfo[0] = totalSpaceLBR.getValue();
+//                        dfInfo[1] = freeSpaceLBR.getValue();
+//                    }
+//                    else {
+//                        LOGGER.warn("Call to GetDiskFreeSpaceEx failed, absPath={}", absPath);
+//                    }
+//                }
+//                // Otherwise, parse the output of 'dir "filePath"' command to retrieve free space information, if
+//                // running Window NT or higher.
+//                // Note: no command invocation under Windows 95/98/Me, because it causes a shell window to
+//                // appear briefly every time this method is called (See ticket #63).
+//                else if(OsVersion.WINDOWS_NT.isCurrentOrHigher()) {
+//                    // 'dir' command returns free space on the last line
+//                    Process process = Runtime.getRuntime().exec(
+//                            (OsVersion.getCurrent().compareTo(OsVersion.WINDOWS_NT)>=0 ? "cmd /c" : "command.com /c")
+//                            + " dir \""+absPath+"\"");
+//
+//                    // Check that the process was correctly started
+//                    if(process!=null) {
+//                        br = new BufferedReader(new InputStreamReader(process.getInputStream()));
+//                        String line;
+//                        String lastLine = null;
+//                        // Retrieves last line of dir
+//                        while((line=br.readLine())!=null) {
+//                            if(!line.trim().equals(""))
+//                                lastLine = line;
+//                        }
+//
+//                        // Last dir line may look like something this (might vary depending on system's language, below in French):
+//                        // 6 Rep(s)  14 767 521 792 octets libres
+//                        if(lastLine!=null) {
+//                            StringTokenizer st = new StringTokenizer(lastLine, " \t\n\r\f,.");
+//                            // Discard first token
+//                            st.nextToken();
+//
+//                            // Concatenates as many contiguous groups of numbers
+//                            String token;
+//                            String freeSpace = "";
+//                            while(st.hasMoreTokens()) {
+//                                token = st.nextToken();
+//                                char c = token.charAt(0);
+//                                if(c>='0' && c<='9')
+//                                    freeSpace += token;
+//                                else if(!freeSpace.equals(""))
+//                                    break;
+//                            }
+//
+//                            dfInfo[1] = Long.parseLong(freeSpace);
+//                        }
+//                    }
+//                }
+//            }
+//            else
+        	if(OsFamily.getCurrent().isUnixBased()) {
                 // Parses the output of 'df -P -k "filePath"' command on UNIX-based systems to retrieve free and total space information
 
                 // 'df -P -k' returns totals in block of 1K = 1024 bytes, -P uses the POSIX output format, ensures that line won't break
@@ -404,11 +405,11 @@ public class LocalFile extends ProtocolFile {
      * @return <code>true</code> if this file is the root of a removable media drive (floppy, CD, DVD, USB drive...). 
      */
     public boolean guessRemovableDrive() {
-        if(IS_WINDOWS && Kernel32.isAvailable()) {
-            int driveType = Kernel32.getInstance().GetDriveType(getAbsolutePath(true));
-            if(driveType!=Kernel32API.DRIVE_UNKNOWN)
-                return driveType==Kernel32API.DRIVE_REMOVABLE || driveType==Kernel32API.DRIVE_CDROM;
-        }
+//        if(IS_WINDOWS && Kernel32.isAvailable()) {
+//            int driveType = Kernel32.getInstance().GetDriveType(getAbsolutePath(true));
+//            if(driveType!=Kernel32API.DRIVE_UNKNOWN)
+//                return driveType==Kernel32API.DRIVE_REMOVABLE || driveType==Kernel32API.DRIVE_CDROM;
+//        }
 
 
         // For other OS that have root drives (OS/2), a weak way to characterize removable drives is by checking if the
@@ -841,29 +842,29 @@ public class LocalFile extends ProtocolFile {
             if(!getRoot().equals(destFile.getRoot()))
                 throw new IOException();
 
-            // Windows 9x or Windows Me: Kernel32's MoveFileEx function is NOT available
-            if(OsVersion.WINDOWS_ME.isCurrentOrLower()) {
-                // The destination file is deleted before calling java.io.File#renameTo().
-                // Note that in this case, the atomicity of this method is not guaranteed anymore -- if
-                // java.io.File#renameTo() fails (for whatever reason), the destination file is deleted anyway.
-                if(destFile.exists())
-                    if(!destJavaIoFile.delete())
-                        throw new IOException();
-            }
-            // Windows NT: Kernel32's MoveFileEx can be used, if the Kernel32 DLL is available.
-            else if(Kernel32.isAvailable()) {
-                // Note: MoveFileEx is always used, even if the destination file does not exist, to avoid having to
-                // call #exists() on the destination file which has a cost.
-                if(!Kernel32.getInstance().MoveFileEx(absPath, destFile.getAbsolutePath(),
-                        Kernel32API.MOVEFILE_REPLACE_EXISTING|Kernel32API.MOVEFILE_WRITE_THROUGH)) {
-                	String errorMessage = Integer.toString(Kernel32.getInstance().GetLastError());
-                	// TODO: use Kernel32.FormatMessage
-                    throw new IOException("Rename using Kernel32 API failed: " + errorMessage);
-                } else {
-                	// move successful
-                	return;
-                }
-            }
+//            // Windows 9x or Windows Me: Kernel32's MoveFileEx function is NOT available
+//            if(OsVersion.WINDOWS_ME.isCurrentOrLower()) {
+//                // The destination file is deleted before calling java.io.File#renameTo().
+//                // Note that in this case, the atomicity of this method is not guaranteed anymore -- if
+//                // java.io.File#renameTo() fails (for whatever reason), the destination file is deleted anyway.
+//                if(destFile.exists())
+//                    if(!destJavaIoFile.delete())
+//                        throw new IOException();
+//            }
+//            // Windows NT: Kernel32's MoveFileEx can be used, if the Kernel32 DLL is available.
+//            else if(Kernel32.isAvailable()) {
+//                // Note: MoveFileEx is always used, even if the destination file does not exist, to avoid having to
+//                // call #exists() on the destination file which has a cost.
+//                if(!Kernel32.getInstance().MoveFileEx(absPath, destFile.getAbsolutePath(),
+//                        Kernel32API.MOVEFILE_REPLACE_EXISTING|Kernel32API.MOVEFILE_WRITE_THROUGH)) {
+//                	String errorMessage = Integer.toString(Kernel32.getInstance().GetLastError());
+//                	// TODO: use Kernel32.FormatMessage
+//                    throw new IOException("Rename using Kernel32 API failed: " + errorMessage);
+//                } else {
+//                	// move successful
+//                	return;
+//                }
+//            }
             // else fall back to java.io.File#renameTo
         }
 
diff --git a/main/com/mucommander/commons/file/impl/local/UNCFile.java b/main/com/mucommander/commons/file/impl/local/UNCFile.java
index 291e87d..5e52f7f 100644
--- a/main/com/mucommander/commons/file/impl/local/UNCFile.java
+++ b/main/com/mucommander/commons/file/impl/local/UNCFile.java
@@ -31,8 +31,8 @@ import com.mucommander.commons.file.impl.local.LocalFile.LocalInputStream;
 import com.mucommander.commons.file.impl.local.LocalFile.LocalOutputStream;
 import com.mucommander.commons.file.impl.local.LocalFile.LocalRandomAccessInputStream;
 import com.mucommander.commons.file.impl.local.LocalFile.LocalRandomAccessOutputStream;
-import com.mucommander.commons.file.util.Kernel32;
-import com.mucommander.commons.file.util.Kernel32API;
+//import com.mucommander.commons.file.util.Kernel32;
+//import com.mucommander.commons.file.util.Kernel32API;
 import com.mucommander.commons.file.util.PathUtils;
 import com.mucommander.commons.io.RandomAccessInputStream;
 import com.mucommander.commons.io.RandomAccessOutputStream;
@@ -353,28 +353,28 @@ public class UNCFile extends ProtocolFile {
         	throw new IOException();
 
         // Windows 9x or Windows Me: Kernel32's MoveFileEx function is NOT available
-        if(OsVersion.WINDOWS_ME.isCurrentOrLower()) {
-        	// The destination file is deleted before calling java.io.File#renameTo().
-        	// Note that in this case, the atomicity of this method is not guaranteed anymore -- if
-        	// java.io.File#renameTo() fails (for whatever reason), the destination file is deleted anyway.
-        	if(destFile.exists())
-        		if(!destJavaIoFile.delete())
-        			throw new IOException();
-        }
-        // Windows NT: Kernel32's MoveFileEx can be used, if the Kernel32 DLL is available.
-        else if(Kernel32.isAvailable()) {
-        	// Note: MoveFileEx is always used, even if the destination file does not exist, to avoid having to
-        	// call #exists() on the destination file which has a cost.
-        	if(!Kernel32.getInstance().MoveFileEx(absPath, destFile.getAbsolutePath(),
-        			Kernel32API.MOVEFILE_REPLACE_EXISTING|Kernel32API.MOVEFILE_WRITE_THROUGH)) {
-        		String errorMessage = Integer.toString(Kernel32.getInstance().GetLastError());
-        		// TODO: use Kernel32.FormatMessage
-        		throw new IOException("Rename using Kernel32 API failed: " + errorMessage);
-        	} else {
-        		// move successful
-        		return;
-        	}
-        }
+//        if(OsVersion.WINDOWS_ME.isCurrentOrLower()) {
+//        	// The destination file is deleted before calling java.io.File#renameTo().
+//        	// Note that in this case, the atomicity of this method is not guaranteed anymore -- if
+//        	// java.io.File#renameTo() fails (for whatever reason), the destination file is deleted anyway.
+//        	if(destFile.exists())
+//        		if(!destJavaIoFile.delete())
+//        			throw new IOException();
+//        }
+//        // Windows NT: Kernel32's MoveFileEx can be used, if the Kernel32 DLL is available.
+//        else if(Kernel32.isAvailable()) {
+//        	// Note: MoveFileEx is always used, even if the destination file does not exist, to avoid having to
+//        	// call #exists() on the destination file which has a cost.
+//        	if(!Kernel32.getInstance().MoveFileEx(absPath, destFile.getAbsolutePath(),
+//        			Kernel32API.MOVEFILE_REPLACE_EXISTING|Kernel32API.MOVEFILE_WRITE_THROUGH)) {
+//        		String errorMessage = Integer.toString(Kernel32.getInstance().GetLastError());
+//        		// TODO: use Kernel32.FormatMessage
+//        		throw new IOException("Rename using Kernel32 API failed: " + errorMessage);
+//        	} else {
+//        		// move successful
+//        		return;
+//        	}
+//        }
         // else fall back to java.io.File#renameTo
 
         if(!file.renameTo(destJavaIoFile))
@@ -600,64 +600,64 @@ public class UNCFile extends ProtocolFile {
 
         try {
                 // Use the Kernel32 DLL if it is available
-                if(Kernel32.isAvailable()) {
-                    // Retrieves the total and free space information using the GetDiskFreeSpaceEx function of the
-                    // Kernel32 API.
-                    LongByReference totalSpaceLBR = new LongByReference();
-                    LongByReference freeSpaceLBR = new LongByReference();
-
-                    if(Kernel32.getInstance().GetDiskFreeSpaceEx(absPath, null, totalSpaceLBR, freeSpaceLBR)) {
-                        dfInfo[0] = totalSpaceLBR.getValue();
-                        dfInfo[1] = freeSpaceLBR.getValue();
-                    }
-                    else {
-                        LOGGER.warn("Call to GetDiskFreeSpaceEx failed, absPath={}", absPath);
-                    }
-                }
-                // Otherwise, parse the output of 'dir "filePath"' command to retrieve free space information, if
-                // running Window NT or higher.
-                // Note: no command invocation under Windows 95/98/Me, because it causes a shell window to
-                // appear briefly every time this method is called (See ticket #63).
-                else if(OsVersion.WINDOWS_NT.isCurrentOrHigher()) {
-                    // 'dir' command returns free space on the last line
-                    Process process = Runtime.getRuntime().exec(
-                            (OsVersion.getCurrent().compareTo(OsVersion.WINDOWS_NT)>=0 ? "cmd /c" : "command.com /c")
-                            + " dir \""+absPath+"\"");
-
-                    // Check that the process was correctly started
-                    if(process!=null) {
-                        br = new BufferedReader(new InputStreamReader(process.getInputStream()));
-                        String line;
-                        String lastLine = null;
-                        // Retrieves last line of dir
-                        while((line=br.readLine())!=null) {
-                            if(!line.trim().equals(""))
-                                lastLine = line;
-                        }
-
-                        // Last dir line may look like something this (might vary depending on system's language, below in French):
-                        // 6 Rep(s)  14 767 521 792 octets libres
-                        if(lastLine!=null) {
-                            StringTokenizer st = new StringTokenizer(lastLine, " \t\n\r\f,.");
-                            // Discard first token
-                            st.nextToken();
-
-                            // Concatenates as many contiguous groups of numbers
-                            String token;
-                            String freeSpace = "";
-                            while(st.hasMoreTokens()) {
-                                token = st.nextToken();
-                                char c = token.charAt(0);
-                                if(c>='0' && c<='9')
-                                    freeSpace += token;
-                                else if(!freeSpace.equals(""))
-                                    break;
-                            }
-
-                            dfInfo[1] = Long.parseLong(freeSpace);
-                        }
-                    }
-                }
+//                if(Kernel32.isAvailable()) {
+//                    // Retrieves the total and free space information using the GetDiskFreeSpaceEx function of the
+//                    // Kernel32 API.
+//                    LongByReference totalSpaceLBR = new LongByReference();
+//                    LongByReference freeSpaceLBR = new LongByReference();
+//
+//                    if(Kernel32.getInstance().GetDiskFreeSpaceEx(absPath, null, totalSpaceLBR, freeSpaceLBR)) {
+//                        dfInfo[0] = totalSpaceLBR.getValue();
+//                        dfInfo[1] = freeSpaceLBR.getValue();
+//                    }
+//                    else {
+//                        LOGGER.warn("Call to GetDiskFreeSpaceEx failed, absPath={}", absPath);
+//                    }
+//                }
+//                // Otherwise, parse the output of 'dir "filePath"' command to retrieve free space information, if
+//                // running Window NT or higher.
+//                // Note: no command invocation under Windows 95/98/Me, because it causes a shell window to
+//                // appear briefly every time this method is called (See ticket #63).
+//                else if(OsVersion.WINDOWS_NT.isCurrentOrHigher()) {
+//                    // 'dir' command returns free space on the last line
+//                    Process process = Runtime.getRuntime().exec(
+//                            (OsVersion.getCurrent().compareTo(OsVersion.WINDOWS_NT)>=0 ? "cmd /c" : "command.com /c")
+//                            + " dir \""+absPath+"\"");
+//
+//                    // Check that the process was correctly started
+//                    if(process!=null) {
+//                        br = new BufferedReader(new InputStreamReader(process.getInputStream()));
+//                        String line;
+//                        String lastLine = null;
+//                        // Retrieves last line of dir
+//                        while((line=br.readLine())!=null) {
+//                            if(!line.trim().equals(""))
+//                                lastLine = line;
+//                        }
+//
+//                        // Last dir line may look like something this (might vary depending on system's language, below in French):
+//                        // 6 Rep(s)  14 767 521 792 octets libres
+//                        if(lastLine!=null) {
+//                            StringTokenizer st = new StringTokenizer(lastLine, " \t\n\r\f,.");
+//                            // Discard first token
+//                            st.nextToken();
+//
+//                            // Concatenates as many contiguous groups of numbers
+//                            String token;
+//                            String freeSpace = "";
+//                            while(st.hasMoreTokens()) {
+//                                token = st.nextToken();
+//                                char c = token.charAt(0);
+//                                if(c>='0' && c<='9')
+//                                    freeSpace += token;
+//                                else if(!freeSpace.equals(""))
+//                                    break;
+//                            }
+//
+//                            dfInfo[1] = Long.parseLong(freeSpace);
+//                        }
+//                    }
+//                }
         }
         finally {
             if(br!=null)
diff --git a/main/com/mucommander/desktop/DesktopManager.java b/main/com/mucommander/desktop/DesktopManager.java
index 5aeea3d..a660bcb 100644
--- a/main/com/mucommander/desktop/DesktopManager.java
+++ b/main/com/mucommander/desktop/DesktopManager.java
@@ -38,10 +38,10 @@ import com.mucommander.desktop.kde.ConfiguredKde3DesktopAdapter;
 import com.mucommander.desktop.kde.ConfiguredKde4DesktopAdapter;
 import com.mucommander.desktop.kde.GuessedKde3DesktopAdapter;
 import com.mucommander.desktop.kde.GuessedKde4DesktopAdapter;
-import com.mucommander.desktop.openvms.OpenVMSDesktopAdapter;
-import com.mucommander.desktop.osx.OSXDesktopAdapter;
-import com.mucommander.desktop.windows.Win9xDesktopAdapter;
-import com.mucommander.desktop.windows.WinNtDesktopAdapter;
+//import com.mucommander.desktop.openvms.OpenVMSDesktopAdapter;
+//import com.mucommander.desktop.osx.OSXDesktopAdapter;
+//import com.mucommander.desktop.windows.Win9xDesktopAdapter;
+//import com.mucommander.desktop.windows.WinNtDesktopAdapter;
 import com.mucommander.desktop.xfce.GuessedXfceDesktopAdapter;
 
 /**
@@ -161,10 +161,10 @@ public class DesktopManager {
         registerAdapter(new ConfiguredGnomeDesktopAdapter());
 
         // Known OS adapters.
-        registerAdapter(new OpenVMSDesktopAdapter());
-        registerAdapter(new OSXDesktopAdapter());
-        registerAdapter(new Win9xDesktopAdapter());
-        registerAdapter(new WinNtDesktopAdapter());
+//        registerAdapter(new OpenVMSDesktopAdapter());
+//        registerAdapter(new OSXDesktopAdapter());
+//        registerAdapter(new Win9xDesktopAdapter());
+//        registerAdapter(new WinNtDesktopAdapter());
 
 
 
diff --git a/main/com/mucommander/job/TransferFileJob.java b/main/com/mucommander/job/TransferFileJob.java
index fc61dac..30536b7 100644
--- a/main/com/mucommander/job/TransferFileJob.java
+++ b/main/com/mucommander/job/TransferFileJob.java
@@ -27,7 +27,7 @@ import java.security.NoSuchAlgorithmException;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.apple.eio.FileManager;
+//import com.apple.eio.FileManager;
 import com.mucommander.commons.file.AbstractFile;
 import com.mucommander.commons.file.FileOperation;
 import com.mucommander.commons.file.FilePermissions;
@@ -205,19 +205,19 @@ public abstract class TransferFileJob extends FileJob {
         }
 
         // Under Mac OS X only, preserving the file type and creator
-        if(OsFamilies.MAC_OS_X.isCurrent()
-            && sourceFile.hasAncestor(LocalFile.class)
-            && destFile.hasAncestor(LocalFile.class)) {
-
-            String sourcePath = sourceFile.getAbsolutePath();
-            try {
-                FileManager.setFileTypeAndCreator(destFile.getAbsolutePath(), FileManager.getFileType(sourcePath), FileManager.getFileCreator(sourcePath));
-            }
-            catch(IOException e) {
-                // Swallow the exception and do not interrupt the transfer
-                LOGGER.debug("Error while setting Mac OS X file type and creator on destination", e);
-            }
-        }
+//        if(OsFamilies.MAC_OS_X.isCurrent()
+//            && sourceFile.hasAncestor(LocalFile.class)
+//            && destFile.hasAncestor(LocalFile.class)) {
+//
+//            String sourcePath = sourceFile.getAbsolutePath();
+//            try {
+//                FileManager.setFileTypeAndCreator(destFile.getAbsolutePath(), FileManager.getFileType(sourcePath), FileManager.getFileCreator(sourcePath));
+//            }
+//            catch(IOException e) {
+//                // Swallow the exception and do not interrupt the transfer
+//                LOGGER.debug("Error while setting Mac OS X file type and creator on destination", e);
+//            }
+//        }
 
         // This block is executed only if integrity check has been enabled (disabled by default)
         if(integrityCheckEnabled) {

diff --git a/main/com/mucommander/ui/notifier/GrowlNotifier.java b/main/com/mucommander/ui/notifier/GrowlNotifier.java
index 9cb68ae..bf4d758 100644
--- a/main/com/mucommander/ui/notifier/GrowlNotifier.java
+++ b/main/com/mucommander/ui/notifier/GrowlNotifier.java
@@ -20,7 +20,7 @@ package com.mucommander.ui.notifier;
 
 import com.mucommander.commons.runtime.OsFamilies;
 import com.mucommander.text.Translator;
-import com.mucommander.ui.macosx.AppleScript;
+//import com.mucommander.ui.macosx.AppleScript;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -81,11 +81,12 @@ public class GrowlNotifier extends AbstractNotifier {
      * @return true if the script was successfully executed
      */
     private static boolean tellGrowl(String appleScript) {
-        return AppleScript.execute(
-                "tell application \"GrowlHelperApp\"\n" +
-                    "\t"+appleScript+"\n" +
-                "end tell",
-            null);
+//        return AppleScript.execute(
+//                "tell application \"GrowlHelperApp\"\n" +
+//                    "\t"+appleScript+"\n" +
+//                "end tell",
+//            null);
+    	return false;
     }
 
 
@@ -112,11 +113,11 @@ public class GrowlNotifier extends AbstractNotifier {
 
             // Test if Growl is currently running and abort if it is not
             StringBuilder outputBuffer = new StringBuilder();
-            if(!(AppleScript.execute(IS_GROWL_RUNNING_APPLESCRIPT, outputBuffer) && outputBuffer.toString().equals("true"))) {
-            	LOGGER.debug("Growl is not running, aborting");
-
-                return false;
-            }
+//            if(!(AppleScript.execute(IS_GROWL_RUNNING_APPLESCRIPT, outputBuffer) && outputBuffer.toString().equals("true"))) {
+//            	LOGGER.debug("Growl is not running, aborting");
+//
+//                return false;
+//            }
 
             // Register the application (muCommander) with Growl
 
